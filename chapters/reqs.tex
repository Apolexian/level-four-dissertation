\chapter{Requirements and design} \label{chap:reqs}

The following section presents the identified objectives and the methodology we follow for the implementation of $MQuicTT$.
We discuss the steps we have taken to analyse the existing QUIC and MQTT implementations to motivate our choice of libraries.
Additionally, we describe the design choices taken.

\section{Requirements}

In order to analyse QUIC as a transport layer protocol for IoT, we have identified the following requirements using a MoSCoW style analysis:

\begin{itemize}
    \item Must:
    \begin{itemize}
        \item We \textbf{must} create a test case for MQTT using QUIC - MQuicTT.
        \item We \textbf{must} analyse the performance of MQuicTT compared to base MQTT implementations.
        \item We \textbf{must} focus on realistic testing scenarios for evaluation.
    \end{itemize}
    \item Should:
    \begin{itemize}
        \item We \textbf{should} analyse a general methodology for reducing the hardware footprint of transport layer protocols for IoT.
        \item We \textbf{should} analyse the hardware footprint and feature set of the chosen QUIC and TLS libraries.
    \end{itemize}
    \item Could:
    \begin{itemize}
        \item We \textbf{could} create a QUIC extension that uses a lightweight security protocol.
    \end{itemize}
\end{itemize}

From these requirements, we have split the project into the following objectives:

\begin{itemize}
    \item \textbf{O1}: Compare existing QUIC and MQTT implementations that can act as underlying libraries.
    \item \textbf{O2}: Create an abstraction layer for the QUIC specific logic.
    \item \textbf{O3}: Implement MQuicTT by changing the underlying MQTT implementation to use this abstraction layer.
    \item \textbf{O4}: Create a test bench for the network performance analysis of MQuicTT.
    \item \textbf{O5}: Devise a methodology for trimming down the QUIC stack in terms of binary size.
    \item \textbf{O6}: Analyse the components of the MQuicTT binary.
    \item \textbf{O7}: Analyse the features of TLS and possible alternatives.
\end{itemize}

Hence, the rest of this chapter is split into sections corresponding to the design for the implementation centred objectives, that is, \textbf{O1}, \textbf{O2}, \textbf{O3}.
The rest of the objectives are addressed in Chapter~\ref{chapter:eval}.

\section{Design of the implementation}

In this section, we present a comparison of existing QUIC and MQTT implementations that can be used as underlying libraries for MQuicTT.Additionally, we discuss the high-level design of MQuicTT and the approach we have taken when it comes to using existing libraries compared to creating new protocol implementations.


\input{chapters/libs/quic_impls.tex}
\input{chapters/libs/mqtt_impls.tex}

\subsection{MQuicTT design}

To create MQuicTT, we have, as previously seen, opted to use existing implementations of QUIC and MQTT.
An alternate approach to this would be creating implementations from scratch that could be optimised for our use case.
However, we demonstrate an actual use case by opting to use existing libraries.
These libraries have both been built for production use and are relatively widely deployed.
Hence, we are more likely to get accurate results.
In addition to this, the development time needed to create implementations for these protocols from scratch would far exceed this project's scope.

However, we have created an intermediate library that will act as an abstraction from the QUIC logic - $QuicSocket$.
By creating this intermediate library and ensuring that its API mimics a standard TCP socket, we lower the difficulty of porting $rumqtt$ to QUIC.
Additionally, this library can be used for any application that uses the QUIC protocol.

Hence, the design for the implementation has been split into two broad stages.
In the first stage, we create an abstraction around $quinn$ that acts as a socket for the QUIC protocol.
In the second stage we use the resulting socket library to port $rumqtt$ to QUIC.

Further discussion of specific technical choices that we have made during the implementation can be found in Chapter~\ref{chap:impl}.
